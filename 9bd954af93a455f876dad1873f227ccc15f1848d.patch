From 9bd954af93a455f876dad1873f227ccc15f1848d Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?V=C3=ADctor=20Manuel=20Fern=C3=A1ndez=20Castro?=
 <vmfdez90@gmail.com>
Date: Wed, 17 Feb 2016 09:50:12 +0100
Subject: [PATCH] Adding password authentication by default on authd

---
 src/headers/defs.h        |  3 +-
 src/os_auth/main-client.c | 62 ++++++++++++++++++++++++++-----
 src/os_auth/main-server.c | 94 +++++++++++++++++++++++++++++++++++++++++++++--
 3 files changed, 144 insertions(+), 15 deletions(-)

diff --git a/src/headers/defs.h b/src/headers/defs.h
index 61d6c62d..a0402d3b 100644
--- a/src/headers/defs.h
+++ b/src/headers/defs.h
@@ -187,7 +187,9 @@ published by the Free Software Foundation. For more details, go to \n\
 /* Authentication keys file */
 #ifndef WIN32
 #define KEYS_FILE       "/etc/client.keys"
+#define AUTHD_PASS      "/etc/authd.pass"
 #define KEYSFILE_PATH   DEFAULTDIR KEYS_FILE
+#define AUTHDPASS_PATH  DEFAULTDIR AUTHD_PASS
 #else
 #define KEYS_FILE       "client.keys"
 #define KEYSFILE_PATH   KEYS_FILE
@@ -302,4 +304,3 @@ published by the Free Software Foundation. For more details, go to \n\
 #endif
 
 #endif /* __OS_HEADERS */
-
diff --git a/src/os_auth/main-client.c b/src/os_auth/main-client.c
index 36c50fb8..bd317542 100644
--- a/src/os_auth/main-client.c
+++ b/src/os_auth/main-client.c
@@ -59,12 +59,14 @@ static void help_agent_auth()
     print_out("    -v <path>   Full path to CA certificate used to verify the server");
     print_out("    -x <path>   Full path to agent certificate");
     print_out("    -k <path>   Full path to agent key");
+    print_out("    -P <path>   Authorization password")
     print_out(" ");
     exit(1);
 }
 
 int main(int argc, char **argv)
 {
+    int key_added = 0;
     int c;
     int test_config = 0;
 #ifndef WIN32
@@ -74,6 +76,7 @@ int main(int argc, char **argv)
     int sock = 0, port = DEFAULT_PORT, ret = 0;
     const char *dir = DEFAULTDIR;
     const char *group = GROUPGLOBAL;
+    char *authpass = NULL;
     const char *manager = NULL;
     const char *ipaddress = NULL;
     const char *agentname = NULL;
@@ -81,12 +84,12 @@ int main(int argc, char **argv)
     const char *agent_key = NULL;
     const char *ca_cert = NULL;
     char lhostname[512 + 1];
-    char buf[2048 + 1];
+    char buf[4096 + 1];
     SSL_CTX *ctx;
     SSL *ssl;
     BIO *sbio;
     bio_err = 0;
-    buf[2048] = '\0';
+    buf[4096] = '\0';
 
 #ifdef WIN32
     WSADATA wsaData;
@@ -95,7 +98,7 @@ int main(int argc, char **argv)
     /* Set the name */
     OS_SetName(ARGV0);
 
-    while ((c = getopt(argc, argv, "Vdhtg:m:p:A:v:x:k:")) != -1) {
+    while ((c = getopt(argc, argv, "Vdhtg:m:p:A:v:x:k:D:P:")) != -1) {
         switch (c) {
             case 'V':
                 print_version();
@@ -113,11 +116,11 @@ int main(int argc, char **argv)
                 group = optarg;
                 break;
             case 'D':
-                if (!optarg) {
-                    ErrorExit("%s: -D needs an argument", ARGV0);
-                }
-                dir = optarg;
-                break;
+            if (!optarg) {
+                ErrorExit("%s: -g needs an argument", ARGV0);
+            }
+            dir = optarg;
+            break;
             case 't':
                 test_config = 1;
                 break;
@@ -160,6 +163,11 @@ int main(int argc, char **argv)
                 }
                 agent_key = optarg;
                 break;
+            case 'P':
+            if (!optarg)
+                ErrorExit("%s: -%c needs an argument", ARGV0, c);
+
+            authpass = optarg;
             default:
                 help_agent_auth();
                 break;
@@ -233,6 +241,28 @@ int main(int argc, char **argv)
         exit(1);
     }
 
+    /* Checking if there is a custom password file */
+    if (authpass == NULL) {
+        FILE *fp;
+        fp = fopen(AUTHDPASS_PATH, "r");
+        buf[0] = '\0';
+
+        if (fp) {
+            buf[4096] = '\0';
+            fgets(buf, 4095, fp);
+
+            if (strlen(buf) > 2) {
+                authpass = buf;
+            }
+
+            fclose(fp);
+            printf("INFO: Using password specified on file: %s\n", AUTHDPASS_PATH);
+        }
+    }
+    if (!authpass) {
+        printf("WARN: No authentication password provided. Insecure mode started.\n");
+    }
+
     /* Connect via TCP */
     sock = OS_ConnectTCP(port, ipaddress, 0);
     if (sock <= 0) {
@@ -268,7 +298,13 @@ int main(int argc, char **argv)
 
     printf("INFO: Using agent name as: %s\n", agentname);
 
-    snprintf(buf, 2048, "OSSEC A:'%s'\n", agentname);
+    if (authpass) {
+        snprintf(buf, 2048, "OSSEC PASS: %s OSSEC A:'%s'\n", authpass, agentname);
+    }
+    else {
+        snprintf(buf, 2048, "OSSEC A:'%s'\n", agentname);
+    }
+
     ret = SSL_write(ssl, buf, strlen(buf));
     if (ret < 0) {
         printf("SSL write error (unable to send message.)\n");
@@ -321,11 +357,15 @@ int main(int argc, char **argv)
                         fprintf(fp, "%s\n", key);
                         fclose(fp);
                     }
+                    key_added = 1;
                     printf("INFO: Valid key created. Finished.\n");
                 }
                 break;
             case SSL_ERROR_ZERO_RETURN:
             case SSL_ERROR_SYSCALL:
+                if (key_added == 0) {
+                    printf("ERROR: Unable to create key. Either wrong password or connection not accepted by the manager.\n");
+                }
                 printf("INFO: Connection closed.\n");
                 exit(0);
                 break;
@@ -338,6 +378,9 @@ int main(int argc, char **argv)
     }
 
     /* Shut down the socket */
+    if (key_added == 0) {
+        printf("ERROR: Unable to create key. Either wrong password or connection not accepted by the manager.\n");
+    }
     SSL_CTX_free(ctx);
     close(sock);
 
@@ -345,4 +388,3 @@ int main(int argc, char **argv)
 }
 
 #endif /* LIBOPENSSL_ENABLED */
-
diff --git a/src/os_auth/main-server.c b/src/os_auth/main-server.c
index 7da30951..56b61798 100644
--- a/src/os_auth/main-server.c
+++ b/src/os_auth/main-server.c
@@ -36,6 +36,7 @@ int main()
 
 #include <sys/wait.h>
 #include "auth.h"
+#include "os_crypto/md5/md5_op.h"
 
 /* TODO: Pulled this value out of the sky, may or may not be sane */
 #define POOL_SIZE 512
@@ -61,6 +62,7 @@ static void help_authd()
     print_out("    -g <group>  Group to run as (default: %s)", GROUPGLOBAL);
     print_out("    -D <dir>    Directory to chroot into (default: %s)", DEFAULTDIR);
     print_out("    -p <port>   Manager port (default: %d)", DEFAULT_PORT);
+    print_out("    -n          Disable shared password authentication (not recommended).\n");
     print_out("    -v <path>   Full path to CA certificate used to verify clients");
     print_out("    -x <path>   Full path to server certificate");
     print_out("    -k <path>   Full path to server key");
@@ -68,6 +70,36 @@ static void help_authd()
     exit(1);
 }
 
+/* Generates a random and temporary shared pass to be used by the agents. */
+char *__generatetmppass()
+{
+    int rand1;
+    int rand2;
+    os_md5 md1;
+    char *fstring = NULL;
+    char str1[STR_SIZE +1];
+    char *muname = NULL;
+
+    #ifndef WIN32
+        #ifdef __OpenBSD__
+        srandomdev();
+        #else
+        srandom(time(0) + getpid() + getppid());
+        #endif
+    #else
+        srandom(time(0) + getpid());
+    #endif
+
+    rand1 = random();
+    rand2 = random();
+    muname = getuname();
+
+    snprintf(str1, STR_SIZE, "%d%d%s%d",(int)time(0), rand1, muname, rand2);
+    OS_MD5_Str(str1, md1);
+    fstring = strdup(md1);
+    return(fstring);
+}
+
 /* Function to use with SSL on non blocking socket,
  * to know if SSL operation failed for good
  */
@@ -99,6 +131,7 @@ static void clean_exit(SSL_CTX *ctx, int sock)
 int main(int argc, char **argv)
 {
     FILE *fp;
+    char *authpass = NULL;
     /* Bucket to keep pids in */
     int process_pool[POOL_SIZE];
     /* Count of pids we are wait()ing on */
@@ -125,7 +158,10 @@ int main(int argc, char **argv)
     /* Set the name */
     OS_SetName(ARGV0);
 
-    while ((c = getopt(argc, argv, "Vdhtig:D:m:p:v:x:k:")) != -1) {
+    /* Getting temporary pass. */
+    authpass = __generatetmppass();
+
+    while ((c = getopt(argc, argv, "Vdhtig:D:m:p:v:x:k:n")) != -1) {
         switch (c) {
             case 'V':
                 print_version();
@@ -154,6 +190,8 @@ int main(int argc, char **argv)
             case 't':
                 test_config = 1;
                 break;
+            case 'n':
+                authpass = NULL;
             case 'p':
                 if (!optarg) {
                     ErrorExit("%s: -%c needs an argument", ARGV0, c);
@@ -224,6 +262,30 @@ int main(int argc, char **argv)
     /* Start up message */
     verbose(STARTUP_MSG, ARGV0, (int)getpid());
 
+    /* Checking if there is a custom password file */
+    fp = fopen(AUTHDPASS_PATH, "r");
+    buf[0] = '\0';
+    if (fp) {
+        buf[4096] = '\0';
+        fgets(buf, 4095, fp);
+        if (strlen(buf) > 2) {
+            authpass = buf;
+        }
+        fclose(fp);
+    }
+
+    if (buf[0] != '\0') {
+        verbose("Accepting connections. Using password specified on file: %s",AUTHDPASS_PATH);
+    }
+    else if (authpass) {
+        verbose("Accepting connections. Random password chosen for agent authentication: %s", authpass);
+    }
+    else {
+        verbose("Accepting insecure connections. No password required (not recommended)");
+    }
+
+    /* Getting SSL cert. */
+
     fp = fopen(KEYSFILE_PATH, "a");
     if (!fp) {
         merror("%s: ERROR: Unable to open %s (key file)", ARGV0, KEYSFILE_PATH);
@@ -300,6 +362,7 @@ int main(int argc, char **argv)
                 } while (ret <= 0);
 
                 verbose("%s: INFO: New connection from %s", ARGV0, srcip);
+                buf[0] = '\0';
 
                 do {
                     ret = SSL_read(ssl, buf, sizeof(buf));
@@ -311,8 +374,32 @@ int main(int argc, char **argv)
                 } while (ret <= 0);
 
                 int parseok = 0;
-                if (strncmp(buf, "OSSEC A:'", 9) == 0) {
-                    char *tmpstr = buf;
+                char *tmpstr = buf;
+
+                /* Checking for shared password authentication. */
+                if(authpass) {
+                    /* Format is pretty simple: OSSEC PASS: PASS WHATEVERACTION */
+                    if (strncmp(tmpstr, "OSSEC PASS:", 12) == 0) {
+                        tmpstr = tmpstr + 12;
+                        if (strlen(tmpstr) > strlen(authpass) && strncmp(tmpstr, authpass, strlen(authpass)) == 0) {
+                            tmpstr = tmpstr + strlen(authpass);
+                            if (*tmpstr == ' ') {
+                                tmpstr++;
+                                parseok = 1;
+                            }
+                        }
+                    }
+                    if (parseok == 0) {
+                        merror("%s: ERROR: Invalid password provided by %s. Closing connection.", ARGV0, srcip);
+                        SSL_CTX_free(ctx);
+                        close(client_sock);
+                        exit(0);
+                    }
+                }
+
+                /* Checking for action A (add agent) */
+                parseok = 0;
+                if (strncmp(tmpstr, "OSSEC A:'", 9) == 0) {
                     agentname = tmpstr + 9;
                     tmpstr += 9;
                     while (*tmpstr != '\0') {
@@ -400,4 +487,3 @@ int main(int argc, char **argv)
     return (0);
 }
 #endif /* LIBOPENSSL_ENABLED */
-
